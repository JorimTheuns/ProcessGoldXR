var THREEcolor: new THREE.Color();
var THREEmaterial = new THREE.MeshLineMaterial();

AFRAME.registerComponent('meshlinebezier', {
	schema: {
		color: {
		default:
			'#000'
		},
		lineWidth: {
		default:
			10
		},
		lineWidthStyler: {
		default:
			'1'
		},
		curveFactor: {
		default:
			'0.0'
		},
		depthFactor: {
		default:
			'0.0'
		},
		path: {
		default:
			[{
					x: 0,
					y: 0,
					z: 0
				}, {
					x: 0,
					y: 1,
					z: 0
				}, {
					x: 0,
					y: 0,
					z: 1
				}, {
					x: 1,
					y: 1,
					z: 0
				}
			],
			// Deserialize path in the form of comma-separated vec3s: `0 0 0, 1 1 1, 2 0 3`.
			parse: function (value) {
				return value.split(',').map(AFRAME.utils.coordinates.parse);
			},
			// Serialize array of vec3s in case someone does setAttribute('line', 'path', [...]).
			stringify: function (data) {
				return data.map(AFRAME.utils.coordinates.stringify).join(',');
			}
		}
	},

	init: function () {
		this.resolution = new THREE.Vector2(window.innerWidth, window.innerHeight);

		var sceneEl = this.el.sceneEl;
		sceneEl.addEventListener('render-target-loaded', this.do_update.bind(this));
		sceneEl.addEventListener('render-target-loaded', this.addlisteners.bind(this));

		/*
		if (sceneEl.hasLoaded) {

		console.log('has loaded');
		this.do_update(); //never happens ?

		} else {

		sceneEl.addEventListener('render-target-loaded', this.do_update.bind(this));

		}
		 */
	},

	addlisteners: function () {

		//var canvas = this.el.sceneEl.canvas;

		// canvas does not fire resize events, need window
		window.addEventListener('resize', this.do_update.bind(this));

		//console.log( canvas );
		//this.do_update() ;

	},

	do_update: function () {

		var canvas = this.el.sceneEl.canvas;
		this.resolution.set(canvas.width, canvas.height);
		//console.log( this.resolution );
		this.update();

	},

	update: function () {
		//cannot use canvas here because it is not created yet at init time
		//console.log("canvas res:");
		//console.log(this.resolution);
		var material = new THREE.MeshLineMaterial({
				color: new THREE.Color(this.data.color),
				resolution: this.resolution,
				sizeAttenuation: false,
				lineWidth: this.data.lineWidth,
				//near: 0.1,
				//far: 1000
			});

		let p = this.data.path;
		let cF = this.data.curveFactor;
		var numberOfCurves = (p.length - 1) / 3;
		var totalPoints = [];

		for (let i = 0; i < numberOfCurves; i++) {
			let j = i*3;
			var curve = new THREE.CubicBezierCurve3(
					new THREE.Vector3(p[0 + j].x, p[0 + j].y, p[0 + j].z),
					new THREE.Vector3(p[1 + j].x, p[1 + j].y, p[1 + j].z),
					new THREE.Vector3(p[2 + j].x, p[2 + j].y, p[2 + j].z),
					new THREE.Vector3(p[3 + j].x, p[3 + j].y, p[3 + j].z));

			var points = curve.getPoints(25);
			totalPoints.push(...points);
		}
		//console.log(totalPoints);
		var geometry = new THREE.Geometry();

		totalPoints.forEach(function (vec3) {
			
			var flat = [vec3.x, vec3.y, vec3.z];
			var curved = [vec3.x, vec3.y, getZ(vec3.x, 2)];
			console.log('Curve Factor is: ' + cF);
			var outcome = lerp(flat, curved, cF);
			
			geometry.vertices.push(
				new THREE.Vector3(outcome.x, outcome.y, outcome.z));
		});

		var widthFn = new Function('p', 'return ' + this.data.lineWidthStyler);
		//? try {var w = widthFn(0);} catch(e) {warn(e);}
		var line = new THREE.MeshLine();
		line.setGeometry(geometry, widthFn);
		this.el.setObject3D('mesh', new THREE.Mesh(line.geometry, material));
	},

	remove: function () {
		this.el.removeObject3D('mesh');
	}
});


function getZ(x, rad) {
	return rad - (Math.sqrt((rad * rad) - (x * x)))
}

function lerp(a, b, t) {
    var len = a.length;
    if(b.length != len) return;

    var x = [];
    for(var i = 0; i < len; i++)
        x.push(a[i] + t * (b[i] - a[i]));
    return x;
}

//Example of lerp
/* 
var A = [1,2,3];
var B = [2,5,6];

var X = lerp(A, B, 0.01);

*/
