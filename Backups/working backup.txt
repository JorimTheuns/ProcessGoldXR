var pgData;

d3.json("pgdata.json", function (error, json) {
	if (error)
		return console.warn(error);
	pgData = json;
	visualise();
});

function visualise() {

	var scene = d3.select('a-scene');
	var nodeData = pgData.graph.nodes;
	var edgeData = pgData.graph.edges;

	var depth = false;

	var depthCurve = new THREE.CubicBezierCurve(
			new THREE.Vector2(0, 0),
			new THREE.Vector2(0, -1),
			new THREE.Vector2(1, -1),
			new THREE.Vector2(1, 0));

	let scaleFactor = 0.4;
	let xSkew = 2;
	let ySkew = 1;
	let yShift = 0.5;

		var pureScale = d3.scaleLinear()
		.domain([-100, 100])
		.range([-scaleFactor * xSkew, scaleFactor * xSkew]);

	let xShift = pureScale(pgData.graph.centralpoint.x);

	console.log(xShift);

	var scale = d3.scaleLinear()
		.domain([-100, 100])
		.range([-scaleFactor * xSkew - xShift, scaleFactor * xSkew - xShift]);

	var invert = d3.scaleLinear()
		.domain([-100, 100])
		.range([scaleFactor * ySkew + yShift, -scaleFactor * ySkew + yShift]);

	var xmax = scale(d3.max(nodeData, function (d) {
				return d.x;
			}));
	var xmin = scale(d3.min(nodeData, function (d) {
				return d.x;
			}));
	var ymax = invert(d3.max(nodeData, function (d) {
				return d.y;
			}));
	var ymin = invert(d3.min(nodeData, function (d) {
				return d.y;
			}));

	console.log('X extent is: ' + xmin + ' to ' + xmax + ': Y extent is ' + ymin + ' to ' + ymax);

	//select all virtual nodes
	// using d3's enter/update/exit pattern to draw and bind dom elements
	scene.selectAll("#nodes")
	.data(nodeData)
	.enter()
	.append("a-entity")
	.attr('id', 'node')
	.attr('position', function (d) {
		//console.log(scale(d.x) + ' ' + invert(d.y) + ' 0');
		return scale(d.x) + ' ' + invert(d.y) + ' 0'
	})
	.attr('geometry', function (d) {
		return 'primitive: plane; height: ' + pureScale(d.h) + ' ; width: ' + pureScale(d.w)
	})
	.attr('material', 'shader: flat; color: white; side: double')
	.attr('text', function (d) {
		var textString = 'color: black; align: center; value: ' + d.name + '; width: ' + pureScale(d.h) * 10;
		//console.log(textString);
		return textString
	})
	.on("click", function (d, i) {
		console.log("click", i, d)
	});

	//Create lines
	scene.selectAll("#lines")
	.data(edgeData)
	.enter()
	.append("a-entity")
	.attr('id', 'line')
	.attr("meshlinebezier", function (d) {
		var pathString = ' ';
		let cp = d.controlpoints;
		for (let i = 0; i < cp.length - 1; i++) {
			pathString += scale(cp[i].x) + ' ' + invert(cp[i].y) + ' -0.1';
		}
		pathString += scale(cp[cp.length - 1].x) + ' ' + invert(cp[cp.length - 1].y) + ' -0.1';
		//console.log(pathString);
		return 'lineWidth: 1; color: #E20049; path: ' + pathString
	});

	//On click, alternate between states
	scene.on("click", function () {

		depth = !depth;

		//Update all lines
		scene.selectAll("#line")
		.data(edgeData)
		.transition()
		.duration(1000)
		.attrTween("meshlinebezier", function (d) {
			var old_data = this.components.meshlinebezier.data.path;
			//var old_position_string = old_data.x + ' ' + old_data.y + ' ' + old_data.z

			var new_pathString = ' ';
			var old_pathString = ' ';
			let cp = d.controlpoints;
			var depthPoints = depthCurve.getPoints(cp.length - 1);
			for (let i = 0; i < cp.length - 1; i++) {
				if (depth) {
					new_pathString += scale(cp[i].x) + ' ' + invert(cp[i].y) + ' ' + depthPoints[i].y + ', ';
					old_pathString += scale(cp[i].x) + ' ' + invert(cp[i].y) + ' -0.02, ';
				} else {
					new_pathString += scale(cp[i].x) + ' ' + invert(cp[i].y) + ' -0.02, ';
					old_pathString += scale(cp[i].x) + ' ' + invert(cp[i].y) + ' ' + depthPoints[i].y + ', ';
				}
			}
			if (depth) {
				new_pathString += scale(cp[cp.length - 1].x) + ' ' + invert(cp[cp.length - 1].y) + ' ' + depthPoints[cp.length - 1].y;
				old_pathString += scale(cp[cp.length - 1].x) + ' ' + invert(cp[cp.length - 1].y) + ' -0.02';
			} else {
				new_pathString += scale(cp[cp.length - 1].x) + ' ' + invert(cp[cp.length - 1].y) + ' -0.02';
				old_pathString += scale(cp[cp.length - 1].x) + ' ' + invert(cp[cp.length - 1].y) + ' ' + depthPoints[cp.length - 1].y;
			}
			//console.log(new_pathString);
			var new_string = 'lineWidth: 1; color: #E20049; path: ' + new_pathString;
			var old_string = 'lineWidth: 1; color: #E20049; path: ' + old_pathString;
			//console.log(old_string);
			//console.log(new_string);
			return d3.interpolate(old_string, new_string)
		});
	});

}
